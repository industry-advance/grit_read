#![warn(missing_docs)]
#![no_std]

//! This crate provides parsing of RIFF files generated by grit, a tool for converting graphics to a
//! format recognized by the GBA and Nintendo DS consoles.

use core::convert::TryInto;
use core::slice;
use core::u32;

use tiny_riff::*;

static TOP_LEVEL_CHUNK_ID: [u8; 4] = [0x52, 0x49, 0x46, 0x46]; // ASCII: "RIFF"
static HEADER_CHUNK_ID: [u8; 4] = [0x48, 0x44, 0x52, 0x20]; // ASCII: "HDR "
static GFX_CHUNK_ID: [u8; 4] = [0x47, 0x46, 0x58, 0x20]; // ASCII: "GFX "
static MAP_CHUNK_ID: [u8; 4] = [0x4d, 0x41, 0x50, 0x20]; // ASCII: "MAP "
static MTIL_CHUNK_ID: [u8; 4] = [0x4d, 0x54, 0x49, 0x4c]; // ASCII: "MTIL"
static MMAP_CHUNK_ID: [u8; 4] = [0x4d, 0x4d, 0x41, 0x50]; // ASCII: "MMAP"
static PAL_CHUNK_ID: [u8; 4] = [0x50, 0x41, 0x4c, 0x20]; // ASCII: "PAL "

static HEADER_SIZE: usize = 16;

#[derive(Debug, PartialEq, Clone, Copy)]
/// A header describing the GRF data.
pub struct GrfHeader {
    gfx_attr: u8,
    map_attr: u8,
    mmap_attr: u8,
    pal_attr: u8,
    /// Width of a single tile.
    pub tile_width: u8,
    /// Height of a single tile.
    pub tile_height: u8,
    meta_width: u8,
    meta_height: u8,
    gfx_width: u32,
    gfx_height: u32,
}

#[derive(Debug, PartialEq, Clone)]
/// The parsed GRF format data.
pub struct Grf<'a> {
    /// GRF header, see https://www.coranac.com/man/grit/html/grit.htm#ssec-info-grf
    /// for additional information.
    pub header: GrfHeader,
    /// Slice containing graphics data
    /// # TODO: Parse
    gfx: &'a [u8],
    /// Slice containing map data
    /// # TODO: Parse
    map: Option<&'a [u8]>,
    mtil: &'a [u8],
    mmap: &'a [u8],
    /// Slice containing palette data
    /// # TODO: Convert to u16
    pal: &'a [u8],
}

/// Describes error conditions which may be encountered when parsing the GRF.
#[derive(Debug, PartialEq, Clone, Copy)]
pub enum GrfError {
    /// The underlying RIFF parser returned an error.
    RiffError(tiny_riff::RiffError),
    /// An expected RIFF chunk was not found.
    ChunkNotFound(ChunkId),
    /// Grit's header was of the wrong size.
    WrongHeaderSize(usize),
}

impl From<RiffError> for GrfError {
    fn from(err: RiffError) -> GrfError {
        return GrfError::RiffError(err);
    }
}

impl<'a> Grf<'a> {
    /// Parse a byte slice into a GRF.
    /// Note that the backing data has to live for `'static`, as we can't return subslices from it
    /// by reference otherwise and would have to copy.
    ///
    /// # Safety
    /// WARNING: As the Rust borrow checker is currently too stupid to understand
    /// that the tiny_riff crate creates a struct with the only field we actually care about returning
    /// being nothing more than a slice into data and that the rest of the struct therefore doesn't need
    /// to survive the function, we perform some unsafe fuckery to give the data back it's static lifetime
    /// so we can return it.
    /// Even though this should be safe because data has the same lifetime as the slice where it lives, you really shouldn't rely on it though.
    pub fn from_slice(data: &'a [u8]) -> Result<Grf<'a>, GrfError> {
        let riff = RiffReader::new(data);
        // Needed to satisfy the borrow checker
        let top_level_chunk = obtain_chunk_or_error(&riff, TOP_LEVEL_CHUNK_ID)?;
        // Due to a bug in the current version of grit, the "GRF " chunk does not declare
        // a length. As a workaround, we skip the 4 bytes of "GRF " chunk ID and start reading
        // the next chunk.
        let top_level_chunk_reader =
            RiffReader::new(&top_level_chunk.data[4..top_level_chunk.data.len()]);

        let header_chunk = obtain_chunk_or_error(&top_level_chunk_reader, HEADER_CHUNK_ID)?;
        let header = GrfHeader::from_chunk(header_chunk)?;

        let gfx_chunk = obtain_chunk_or_error(&top_level_chunk_reader, GFX_CHUNK_ID)?;
        let map_chunk: Option<Chunk>;
        match obtain_chunk_or_error(&top_level_chunk_reader, MAP_CHUNK_ID) {
            Ok(chunk) => map_chunk = Some(chunk),
            Err(err) => match err {
                GrfError::ChunkNotFound(_) => map_chunk = None,
                _ => return Err(err),
            },
        }
        let mtil_chunk = obtain_chunk_or_error(&top_level_chunk_reader, MTIL_CHUNK_ID)?;
        let mmap_chunk = obtain_chunk_or_error(&top_level_chunk_reader, MMAP_CHUNK_ID)?;
        let pal_chunk = obtain_chunk_or_error(&top_level_chunk_reader, PAL_CHUNK_ID)?;

        // WARNING: Code that's probably fucked ahead
        let gfx_chunk_data: &'a [u8] =
            unsafe { slice::from_raw_parts(gfx_chunk.data.as_ptr(), gfx_chunk.data.len()) };
        let map_chunk_data: Option<&'a [u8]> = match map_chunk {
            Some(chunk) => {
                Some(unsafe { slice::from_raw_parts(chunk.data.as_ptr(), chunk.data.len()) })
            }
            None => None,
        };
        let mtil_chunk_data: &'a [u8] =
            unsafe { slice::from_raw_parts(mtil_chunk.data.as_ptr(), mtil_chunk.data.len()) };
        let mmap_chunk_data: &'a [u8] =
            unsafe { slice::from_raw_parts(mmap_chunk.data.as_ptr(), mmap_chunk.data.len()) };
        let pal_chunk_data: &'a [u8] =
            unsafe { slice::from_raw_parts(pal_chunk.data.as_ptr(), pal_chunk.data.len()) };
        return Ok(Grf {
            header: header,
            gfx: gfx_chunk_data,
            map: map_chunk_data,
            mtil: mtil_chunk_data,
            mmap: mmap_chunk_data,
            pal: pal_chunk_data,
        });
    }
}

fn obtain_chunk_or_error<'a>(rdr: &'a RiffReader, id: [u8; 4]) -> Result<Chunk<'a>, GrfError> {
    match rdr.get_chunk(ChunkId::from_ascii(id).unwrap()) {
        Some(val) => match val {
            Ok(val_inner) => return Ok(val_inner),
            Err(err) => return Err(GrfError::RiffError(err)),
        },
        None => return Err(GrfError::ChunkNotFound(ChunkId::from_ascii(id).unwrap())),
    }
}
impl GrfHeader {
    fn from_chunk(chunk: Chunk) -> Result<GrfHeader, GrfError> {
        // Header is of fixed size.
        if chunk.len != HEADER_SIZE {
            return Err(GrfError::WrongHeaderSize(chunk.len));
        }

        return Ok(GrfHeader {
            gfx_attr: chunk.data[0],
            map_attr: chunk.data[1],
            mmap_attr: chunk.data[2],
            pal_attr: chunk.data[3],
            tile_width: chunk.data[4],
            tile_height: chunk.data[5],
            meta_width: chunk.data[6],
            meta_height: chunk.data[7],
            gfx_width: u32::from_le_bytes(chunk.data[8..12].try_into().unwrap()),
            gfx_height: u32::from_le_bytes(chunk.data[12..16].try_into().unwrap()),
        });
    }
}
